## 시간 복잡도(Time Complexity)란?

알고리즘의 성능을 나타내는 지표로, 입력 크기에 따른 연산 횟수를 의미합니다.

- 시간 복잡도가 낮을수록 성능이 좋음
- 입력 크기는 알고리즘이 처리해야 할 데이터양

### 예시 1) 1차원 배열 검색

- **연산 횟수가 가장 작은 경우**  
  찾고자 하는 값이 1차원 배열의 첫 번째 인덱스에 위치한 경우.  
  한 번의 비교로 검색이 끝남 → 연산 횟수 = 1

  ![Image](https://github.com/user-attachments/assets/ab467039-c1fd-47de-9b74-d0d74bcad2e6)

- **연산 횟수가 가장 많은 경우**  
  찾고자 하는 값이 배열에 없거나, 마지막 인덱스에 있는 경우.  
  배열 크기만큼의 비교가 이루어짐 → 연산 횟수 = 배열 크기 N

  ![Image](https://github.com/user-attachments/assets/d3d7c1bc-be47-43e6-b230-bce46e2c61c4)


---


## 알고리즘 수행 시간 측정 방법

### (1) 절대 시간 측정

프로그램을 실행하여 결과가 나올 때까지의 시간을 측정하는 방법입니다.  
실행 환경에 따라 수행 시간이 달라지므로 **코딩 테스트에서는 잘 사용되지 않습니다**.

### (2) 시간 복잡도 측정

알고리즘이 시작한 순간부터 결과값이 나올 때까지의 **연산 횟수**를 측정합니다.  
측정 결과는 보통 최선(Best), 평균(Normal), 최악(Worst)으로 나뉩니다.

하지만 실무나 코딩 테스트에서는 연산 횟수의 **정확한 수치보다는 추이**를 보며  
**입력값이 충분히 커졌을 때의 증가 경향**을 기준으로 판단합니다.

➡️ 이를 위해 사용하는 것이 **점근적 표기법**이며, 일반적으로 **최악의 경우**를 기준으로 삼습니다.


---


## 빅오 표기법(Big-O Notation)

가장 많이 사용하는 점근적 표기법으로, **상한선을 표현**합니다.  
프로그램의 연산 횟수가 `f(x)`일 때, 최고차항만 남기고 계수를 제거하여  
`O(...)`로 표기합니다.

- 하한선을 표현하는 표기법은 **빅오메가(Ω)**
- 함수의 증가폭: `지수함수 > 다항함수 > 로그함수 > 상수`

| 함수 f(x) | 빅오 표기 |
|----------|------------|
| 3x² + 5x + 6 | O(x²)     |
| x + logx    | O(x)      |
| 2ˣ + 10x⁵ + 5x² | O(2ˣ) |

### 빅오의 수학적 정의

![Image](https://github.com/user-attachments/assets/bfc63d96-5e33-4c34-8b40-8f2b6581597e)

- 특정 x 값 이후부터 항상 `f(x) ≤ C * g(x)` 인 경우
- 여기서 `C`는 상수

➡️ 이 조건이 만족되면, `f(x)`의 최악의 시간 복잡도는 `O(g(x))`입니다.

**예시**  
`f(x) = x² + 3x + 5` 라면, `g(x) = x²`, `C = 2` 정도를 잡을 수 있습니다.  
→ x가 충분히 크면 항상 `C * g(x)`가 `f(x)`를 상회하게 됩니다.

**왜 최고차항만 남기고 계수를 없애는가?**  
> x가 무한히 커질수록 함수 간 y값 격차는 무시할 수 있을 정도로 커짐.
> 즉, **정확한 연산 횟수보다 추이가 중요**하며,  
> 충분히 큰 x값이라 가정하기에, 계수는 무시하고 최고차항만 남겨도 충분함.


---


## 시간 복잡도를 코딩 테스트에서 활용하는 방법

코딩 테스트는 시간 제한이 있으므로, **작성한 알고리즘이 시간 내에 실행될 수 있는지**  
빅오 표기법으로 분석해보는 것이 중요합니다.

- 보통 1초에 연산 횟수는 1,000만~3,000만 정도로 고려해서 시간 복잡도를 생각하면 됨.
- 따라서, 제한 시간 1초라면 연산 횟수가 3,000만이 넘는 알고리즘을 사용하면 시간이 초과됨.

**예시**  
작성한 알고리즘의 시간 복잡도가 O(N)인데, 주어진 데이터 개수가 5,000만 개라면 해당 알고리즘을 사용해서는 안되는 것입니다. 

➡️ 따라서, 시간 복잡도를 분석하며 적절한 알고리즘을 선택해야 합니다.


> 각 시간 복잡도를 구체적인 예시와 함께 생각하면 실제 알고리즘과 잘 접목할 수 있음.
>
> - **O(N!)**: 순열 - N개의 카드를 순서대로 뽑는 경우  
> - **O(2ⁿ)**: 부분 집합 - 입력이 1 증가할 때마다 경우의 수가 2배  
> - **O(N²)**: 2차원 배열 전체 순회  
> - **O(N)**: 1차원 배열 순회  
> - **O(logN)**: 이진 탐색 - 작업량이 절반씩 줄어듦  
> - **O(1)**: 상수 시간 - 배열 특정 위치 접근, 수학 공식에 의해 값이 한번에 나오는 경우 등


---


## 예제 풀이

문제 정의 → 연산 횟수 측정 → 시간 복잡도 분석

### 1. 별 찍기 문제

- **문제**: 숫자 N을 입력받아, N번째 줄까지 별을 1개부터 N개까지 출력
  ![Image](https://github.com/user-attachments/assets/6de30ceb-ffd7-423c-a5b0-e59ea5c69080)

### 2. 박테리아 수명 문제

- **문제**: 박테리아 수가 N일 때, 매년 절반으로 줄어든다면 언제 모두 소멸하는가?  
  (예: N = 16 → 결과값은 5)
  ![Image](https://github.com/user-attachments/assets/d0742ff8-82b8-4c24-9e7e-a777522fa0ef)
